#+OPTIONS: toc:nil \n:t
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{Heiti SC}
------
layout: post
title: "OpenGL 渲染管线"
date: 2019-10-31 12:40:20 +0800
categories: OpenGL graphics
tags: OpenGL graphics
excerpt: 渲染管线顾名思义就是 OpenGL 在渲染的过程中需要采取的一系列的操作。这一系列操作的组合就被称之为渲染管线。
description: 渲染管线顾名思义就是 OpenGL 在渲染的过程中需要采取的一系列的操作。这一系列操作的组合就被称之为渲染管线。
------


渲染管线顾名思义就是 OpenGL 在渲染的过程中需要采取的一系列的操作。这一系列操作的组合就被称之为渲染管线。


*** 渲染管线

渲染管线出现的主要步骤如下所示

#+BEGIN_SRC html
  <img src="https://www.khronos.org/opengl/wiki_opengl/images/RenderingPipeline.png" alt="Monocerus glaucus" />
#+END_SRC

在 OpenGL 中， 每次发起渲染操作的时候都会生成一个新的渲染管线。

初始化渲染管线需要两个必要的东西
1. 顶点描述数据 [[#Vertex Specification]]。 描述数据一般来自于：顶点缓冲对象（VBO）或者顶点数组对象（VAO）中。
2. 可执行的渲染程序， 这个可执行程序中包括一个或多个用 GLSL 编写的着色器程序。

一旦渲染管线完成初始化的工作，渲染管线会按照如下的顺序依次执行（假设顶点数据来自 VBO）：

1. 顶点处理 [[#Vertex Processing]]
   1. 每一个从 VBO 获取到的数据都会通过 Vertex Shader 的代码进行相应的计算。Vertex Shader 的输入是一个一个的顶点，
      输出是经过 shader 计算处理后的顶点。
   2. [可选] 细分着色
   3. 几何着色阶段，这个阶段会根据顶点的属性，生成新的几何图元。
2. 顶点后置处理阶段（Vertex Post-Processing）[[#Vertex Post-Processing]]
   1. Transform Feedback 在这个阶段完成
   2. 图元裁剪，透视分割，视口变换都在这个阶段完成      
3. 图元装配（Primitive Assembly） [[#Primitive Assembly]]
4. 光栅化
5. 片段着色阶段
6. 逐个采样操作
   1. 裁剪测试（Scissor Test）
   2. 模板测试（Stencil Test）
   3. 深度测试（Depth Test）
   4. 混合（Blending）
   5. 逻辑操作 (Logical Operations)
   6. 写入掩码 (Write Mask)


*** 顶点数据
    :PROPERTIES:
    :CUSTOM_ID: Vertex Specification
    :END:

顶点数据的准备过程发生 CPU 端。 运行在 CPU 上的应用程序生成一组有序的顶点数据，并将这一组顶点数据发送给渲染管线。
这组顶点数据描述了一个图元的边界，比如三角形的三个顶点的位置。这里的图元指的是，我们在构成复杂模型的基本单元，基本单元
有三角形，线段，点。这一组顶点在渲染管线的后续阶段会被组装成相对应的图元。

顶点数据阶段涉及到的对象主要有两个：顶点数组对象，顶点缓存对象。
顶点数组对象定义了每个顶点的数据是什么。顶点缓冲对象定义了顶点数据的存储缓冲。

一个顶点数据包含了一系列的顶点属性。每个属性都包含一组数据。比如顶点位置属性 (position), 包含了 x, y, z. 顶点颜色属性包含
R, G, B, A 四个分量。 渲染管线的后续阶段会使用属性数据进行相应的计算，比如完成波浪的计算，或者颜色的混合。顶点属性并不一定需要
是位置或者颜色之类的数据，顶点属性可以是任何形式的数据。比如如果你在做一个粒子系统的时候，对于每个顶点处理的时候可能会给顶点
添加一个加速度的属性，还要给顶点添加一个速度的属性，还需要给顶点添加一个方向的属性，这些都可以通过顶点属性的方式添加到顶点数据中

*** 顶点渲染
 
准备数据的过程主要在 CPU 端执行，CPU 端会将数据放到 GPU 显存指定的地方. 当应用程序做完所有的准备工作后，可以通过向 GPU 发送一条渲染命令（Draw Call）
来进行渲染。这条 Draw Call 命令主要包含的内容有几个

1. 渲染命令的类型
2. 数据的位置
3. 对应的渲染管线代码在哪里

在发起 draw call 后，GPU 就会按照渲染管线所定义的阶段依次执行。

*** 顶点处理
    :PROPERTIES:
    :CUSTOM_ID: Vertex Processing
    :END:

顶点着色阶段是完全可编程的。意味着应用程序程序员，完全可以通过编写顶点着色程序来自定义对顶点的操作。顶点着色阶段也被拆分为不同的阶段。每个阶段通过不同的着色程序来完成
自定义。这些阶段分别如下

**** 顶点着色

顶点着色程序主要针对单个独立的顶点进行操作。这些操作通过顶点用户定义的 GLSL 程序自定义。 从顶点渲染阶段传入的所有的顶点经过自定义的程序处理后变成输出顶点数据。

顶点着色可以定义自己的顶点属性作为顶点数据输出。比如定义 ~out float verlocity~. 虽然顶点着色程序是完全可编程的，但是顶点着色还是有一定的限制。

为了后续的顶点渲染，有一个 特殊的输出变量 gl_Position 必须在顶点着色器中完成这个输出变量的赋值操作。

另外一个限制是，顶点着色一次只处理一个顶点，并且输出也只能是一个顶点相关的数据，不能新生成顶点。

**** 细分着色

细分着色阶段分为三个阶段，分别为
1. 细分着色控制着色器（可编程）
2. 细分器（固定管线）
3. 细分着色求值器（可编程）

细分着色器的常用的场景是： 假设你有一个球型的模型，当照相机距离球比较远的时候，你希望在不影响图像质量的情况下尽量用少的多边形进行渲染。当摄像机距离球比较近的时候，你希望
使用较多的三角形来绘球，这样球展示的会比较平滑。这种情况我们可以通过细分着色阶段来实现。细分着色控制着色器负责计算需要将一个图元拆分为几个更小的图元。并将数量传递给下个阶段。
固定的不可编程的细分器使用计算出来的细分数进行图元的拆分。我们可以在细分着色求值器中编写自定义的代码来完成插值，或者其他处理代码来完成对细分的图元进行进一步的处理。
**** 几何着色
几何着色主要用来处理图元，决定是否生成新的图元或者抛弃当前图元。

这个主要的使用场景是：比如你需要做一个撞击破碎的效果，此时在撞击的过程中，你就需要根据撞击的顶点计算，生成不同的顶点用来完成破碎的小碎片的模型。

*** 顶点后置处理阶段
    :PROPERTIES:
    :CUSTOM_ID: Vertex Post-Processing
    :END:
在顶点数据处理后，进入了顶点后置处理阶段，这个阶段，主要有一些固定的管线程序组成。主要有如下几个

**** 变换反馈（Transform Feedback）
     在做粒子特效的时候，我们在计算一个粒子的速度，位置和方向的时候（在 CPU 端），我们需要使用已经经过顶点处理的数据，这个阶段将我们进过计算的顶点数据发送到指定的缓冲对象中。我们可以通过使用缓冲对象中
的值完成碰撞检测，速度计算等特性。

**** 裁剪

     所有的物体构建的时候都是在模型座标系，或者全局座标系，当需要展示到屏幕的时候，我们需要将所有的顶点转换到观察者座标系。整个裁剪的过程基于 ~gluPerpestive, glOrtho~ 等定义的视景体进行裁剪。
裁剪就是将和视景体边缘有重合的图元分成多个图元，并且将不在视景体内部的图元抛弃。

裁剪可以通过视景体裁剪，但是一个 draw call 只能指定一个视景体，这种情况下如果需要对多个顶点采用不同的裁剪方式，只能通过多个 draw call 指定不同的视景体来实现。这种情况下会严重的影响性能。这种
情况下我们可以通过在 glEnable(GL_CLIP_DISTANCE0), 并且在 Vertex Shader 中计算 gl_ClipDistance[0] 的值，就可以完成自定义裁剪。基本上 OpenGL 的实现最少支持 8 通道的自定义裁剪定义（GL_CLIP_DISTANCE0-GL_CLIP_DISTANCE7）。
这种方式可以完成顶点级别的裁剪。

*** 图元装配
    :PROPERTIES:
    :CUSTOM_ID: Primitive Assembly
    :END:
图元装配是将前面阶段所产生的顶点数据计算并且组装成图元序列。图元的类型由用户通过 OpenGL 接口指定。比如指定了6个顶点，并且指定了图元的类型为三角形，那么此时就会生成两个三角形的图元序列。
这个阶段还完成一个比较重要的是处理就是背面剔除

**** 背面剔除
     
     在我们建模的过程中，对于一个球体来讲，有外表面和内表面。往往我们只需要看见一面。对于天空盒我们需要看见内表面，对于篮球，我们需要看见外表面。为了性能考虑，我们不希望另外一面也进行渲染操作，
所以 OpenGL 会对背面进行剔除操作。从而提升性能。
*** 光栅化（不可编程）
    :PROPERTIES:
    :CUSTOM_ID: Rasterization
    :END:
通过前面的渲染管线我们得到了一个图元序列，但是为了展示到二维点阵组成的显示器中，我们必须要对图元进行扫描转换和图元插值，或者称之为光栅化。
光栅化的结果就是一个片段的序列。一个片段包含了一组数据，这组数据主要有：屏幕空间的位置，采样信息，渲染管线前面阶段所产生的各种数据。
*** 片段处理（可编程）
    可以通过片段处理着色程序对光栅化后的片段进行进一步的处理。片段着色器的输出是：深度值，模板值，和颜色值。片段着色器不能控制片段的模板值，只能控制深度值和颜色值。
   
    片段着色阶段是一个可选的阶段。

*** 逐采样处理

在经过片段处理后，我们得到了一系列的片段，我们如何决定这些片段应该如何展示到屏幕上，还需要进行一系列的操作。

首先进行的是一些列的测试操作，如果测试不通过，则片段对应的像素不会被更新到屏幕上。这些测试都需要用户通过 glEnable 开启。这些测试包括

**** 像素归属测试

**** 裁剪测试

**** 模板测试

**** 深度测试

在进过上面的测试后，进入到颜色混合阶段。对于每一个片段的每一个颜色值，需要执行一个特定的混合的操作，这个操作来完成当前已经在帧缓冲中的像素和片段像素的混合计算。很多渐变特新就是通过混合来实现的。
一些对像素的逻辑操作也发生在这个地方

最后片段数据被写入帧缓冲区。 写入掩码可以防止特定值的写入。比如不允许写入深度信息。深度信息，模板信息，颜色信息都可以被阻止或者允许写入。颜色的指定的通道也可以被阻止或者允许写入。
